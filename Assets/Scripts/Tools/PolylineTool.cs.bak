using System.Collections;
using System.Collections.Generic;
using System.IO;
using System;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEditor.Events;
using SharpKml;
using SharpKml.Base;
using SharpKml.Dom;
using SharpKml.Engine;

/// <summary>
/// This Tool creates a sequence of connecting placemarks
/// 
/// each placemark has a line renderer, that connects to the placemark connected after it in the chain. 
/// the placemarks can be though of as a doubly linked list, each stores reference to the one before and after it in the list. 
/// 
/// </summary>
/// <returns></returns>
/// 
public class PolylineTool : Tool
{    
    public override IEnumerator ToolCoroutine( )
    {   
        // a List to store all created placemarks in the line
        //List<Vector3> placemarks = new List<Vector3>();
        List<GameObject> placemarks = new List<GameObject>();

        WaitForEndOfFrame wfeof = new WaitForEndOfFrame();
        ToolController.ToolIsCurrentlyRunning = true;
        ToolController.ToolControllerInterfaceIsCurrentlyRunning = false;



        toolControllerComponent.MeasurementControlUI.gameObject.SetActive(false);
        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS)
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.SetActive(false);


        // hold until trigger is released
        // this avoids instant placement 
        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS)
        {
            while (OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0.8f)
            {
                yield return wfeof;
            }
        }


        // temporary objects
        GameObject TempPlacemark, LastPlaceMark = null, TempPlacemarkInfo = null;
        LineRenderer lr = null;
        Vector3Decimal realPosition;

        // loop until a user chooses to cancel the tool 
        bool shouldStopPlacing = false;
        while (!shouldStopPlacing)
        {
            //Instantiate placemark
            TempPlacemark = Instantiate( toolControllerComponent.PlacemarkObject2 );
            TempPlacemark.transform.localScale *= toolControllerComponent.MarkerScale;
            TempPlacemark.name = "distance placemark";
            bool placemarkConfirmed = false, legalPlacemarkPlace = false;
            bool wasHolding = true;

          
            if (LastPlaceMark != null)
            {
                lr = TempPlacemark.AddComponent<LineRenderer>() as LineRenderer;
                lr.startWidth = lr.endWidth = (float)(toolControllerComponent.MarkerScale * 0.2f);

                lr.material = toolControllerComponent.LineMaterial;

                //lr.SetPosition(1, TempPlacemark.transform.position + Vector3.up * (float)(toolControllerComponent.MarkerScale * 0.5f));
                lr.SetPosition(1, TempPlacemark.transform.position );
                lr.SetPosition(0, LastPlaceMark.transform.position );
            }

            //Handling Placemark
            RaycastHit hit;
            while (placemarkConfirmed == false && shouldStopPlacing == false)
            {
                if (StateSingleton.stateView != StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView != StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS)
                {
                    if (wasHolding == true && OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) < 0.2f)
                        wasHolding = false;
                }
                //Trailing Waypoint
                if (Physics.Raycast(master.transform.position, directionMaster.transform.forward, out hit, 100000))
                {
                     //pos 
                    //TempPlacemark.transform.position = hit.point + (toolControllerComponent.MarkerScale * 2) * Vector3.up;
                    TempPlacemark.transform.position = hit.point;
                    //rotation
                    TempPlacemark.transform.eulerAngles = new Vector3(0f, directionMaster.transform.eulerAngles.y, directionMaster.transform.eulerAngles.z);                    
                    legalPlacemarkPlace = true;

                    //Showing info on toolInfo
                    realPosition = VirtualMeter.CalculateRealPositionOfPoint(TempPlacemark.transform.position - 40 * Vector3.up);                   
                    toolControllerComponent.updateGUIMenus("Current Placemark",
                        "Northing (m): " + realPosition.z.ToString("0.000") +
                        "\nEasting (m): " + realPosition.x.ToString("0.000") +
                        "\nAltitude (m): " + realPosition.y.ToString("0.000")
                        );
                }
                else
                {
                    //If not well placed then invalidate
                    TempPlacemark.transform.position = master.transform.position + directionMaster.transform.forward * 100000;
                    toolControllerComponent.updateGUIMenus("Current Placemark", "Northing (m): undefined \nEasting (m): undefined \nAltitude (m): undefined" );
                    legalPlacemarkPlace = false;  
                }

                if (lr)
                {
                    lr.SetPosition(1, TempPlacemark.transform.position);
                }

                //confirm waypoint
                if (legalPlacemarkPlace && ( Input.GetMouseButton(0) ||
                (
                    (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS) &&
                    OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0.5f && wasHolding == false )
                    )
                )
                {
                    placemarkConfirmed = true;
                    placemarks.Add(TempPlacemark);
                    LastPlaceMark = TempPlacemark;
                }
                
                // whether to cancel out of tool
                // this should also remove potential placemarks
                if (checkIfToolShouldQuit())// || OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger) > 0.90f)
                {
                    shouldStopPlacing = true;
                    Destroy(TempPlacemark);
                    print("stop placing");
                }

                yield return wfeof;
            }            
        }

        if (placemarks.Count > 1)
        {
            //do calculations
            Vector3 uPos1;
            Vector3 uPos2;

            decimal totalDistance = 0m;
            Vector3Decimal meanPosition = new Vector3Decimal(0m, 0m, 0m);

            for (int i = 0; i < placemarks.Count; i++)
            {
                uPos1 = placemarks[i].transform.position;
                if (i < placemarks.Count - 1)
                {
                    uPos2 = placemarks[i + 1].transform.position;
                    totalDistance += VirtualMeter.CalculateRealDistance(uPos1, uPos2);
                }
                meanPosition += VirtualMeter.CalculateRealPositionOfPoint(uPos1);
            }
            meanPosition /= placemarks.Count;
            
            // create value ditionary
            Dictionary<string, decimal> dict = new Dictionary<string, decimal>()
                                                {
                {"Total_Distance(m)",      totalDistance}
                //,{ "Mean_Northing (m)" ,    meanPosition.z }
                //,{ "Mean_Easting (m)" ,     meanPosition.x }
                //,{ "Mean_Altitude (m)" ,    meanPosition.y }
                                                };

            // create tool instance        
            toolControllerComponent.CreateToolInstance("Line",
                "\nTotal_Distance (m): " + totalDistance.ToString("0.000"),
                //"\nMean_Northing (m): " + meanPosition.z.ToString("0.000") +
                //"\nMean_Easting  (m): " + meanPosition.x.ToString("0.000") +
                //"\nMean_Altitude (m): " + meanPosition.y.ToString("0.000"),
                dict, placemarks);
        }
        else
        {
            foreach(var p in placemarks)
            {
                Destroy(p);
            }
            ToolController.ToolIsCurrentlyRunning = false;   
        }     
    }


    public void startToolInterface()
    {

        // PolylineTool myScriptInstance = FindObjectOfType<PolylineTool>();
        toolControllerComponent.MeasurementControlUI.gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_placemark").gameObject.SetActive(false);
        toolControllerComponent.MeasurementControlUI.gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_line").gameObject.SetActive(true);
        toolControllerComponent.MeasurementControlUI.gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_polygon").gameObject.SetActive(false);
        toolControllerComponent.MeasurementControlUI.gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_ruler").gameObject.SetActive(false);


        toolControllerComponent.MeasurementControlUI.gameObject.transform.Find("UpperPanel").gameObject.transform.Find("Text").gameObject.GetComponent<Text>().text = "Line tool";
        toolControllerComponent.MeasurementControlUI.gameObject.transform.Find("Content").gameObject.transform.Find("StopTool").gameObject.GetComponent<Button>().onClick.AddListener(CancelButton);

        toolControllerComponent.MeasurementControlUI.SetActive(true);
        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS)
        {
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.transform.Find("UpperPanel").gameObject.transform.Find("Text").gameObject.GetComponent<Text>().text = "Line tool";
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.SetActive(true);

            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_placemark").gameObject.SetActive(false);
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_line").gameObject.SetActive(true);
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_polygon").gameObject.SetActive(false);
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_ruler").gameObject.SetActive(false);
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.transform.Find("Content").gameObject.transform.Find("StopTool").gameObject.GetComponent<Button>().onClick.AddListener(CancelButton);

            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").transform.localPosition = new Vector3(0.0f, -400.0f, 0.0f);

        }
        PauseAndGUIBehaviour.isToolMenu = false;
        ToolController.ToolControllerInterfaceIsCurrentlyRunning = true;


        //  StartCoroutine(this.OnUse());
    }

    public void CancelButton()
    {
        // toolControllerComponent.ToolMenuInstance.GetComponent<CanvasGroup>().alpha = 1;

        // StopGPSTracking(false);
        toolControllerComponent.MeasurementControlUI.SetActive(false);

        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS)
        {
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.SetActive(false);
        }


        if (PauseAndGUIBehaviour.isPause)
            PauseAndGUIBehaviour.isPause = false;
        ToolController.ToolIsCurrentlyRunning = false;
        ToolController.ToolControllerInterfaceIsCurrentlyRunning = false;


    }



    public override GameObject LoadFromFile(string FilePath)
    {
        List<GameObject> placemarks = new List<GameObject>();
        LineRenderer lr = null;

        if (File.Exists(FilePath))
        {
            String fileData = System.IO.File.ReadAllText(FilePath);
            String[] lines = fileData.Split("\n"[0]);
            GameObject TempPlacemark, LastPlaceMark = null;

            foreach (String line in lines)
            {
                String[] data = line.Split(","[0]);
                if (data.Length == 3) // discard non-coordinate lines
                {
                    decimal x = decimal.Parse(data[0]);
                    decimal y = decimal.Parse(data[1]);
                    decimal z = decimal.Parse(data[2]);

                    TempPlacemark = Instantiate(toolControllerComponent.PlacemarkObject);
                    TempPlacemark.transform.localScale *= toolControllerComponent.MarkerScale;
                    TempPlacemark.name = "distance placemark";

                    TempPlacemark.transform.position = new Vector3((float)x, (float)y, (float)z);

                    if (LastPlaceMark != null)
                    {
                        lr = TempPlacemark.AddComponent<LineRenderer>() as LineRenderer;
                        lr.startWidth = lr.endWidth = (float)(toolControllerComponent.MarkerScale * 0.5f);

                        lr.material = toolControllerComponent.LineMaterial;

                        lr.SetPosition(1, TempPlacemark.transform.position + Vector3.up * (float)(toolControllerComponent.MarkerScale * 0.5f));
                        lr.SetPosition(0, LastPlaceMark.transform.position + Vector3.up * (float)(toolControllerComponent.MarkerScale * 0.5f));
                    }
                    LastPlaceMark = TempPlacemark;
                    placemarks.Add(TempPlacemark);
                }
            }      

            //do calculations
            Vector3 uPos1;
            Vector3 uPos2;

            decimal totalDistance = 0m;
            Vector3Decimal meanPosition = new Vector3Decimal(0m, 0m, 0m);

            for (int i = 0; i < placemarks.Count; i++)
            {
                uPos1 = placemarks[i].transform.position;
                if (i < placemarks.Count - 1)
                {
                    uPos2 = placemarks[i + 1].transform.position;
                    totalDistance += VirtualMeter.CalculateRealDistance(uPos1, uPos2);
                }
                meanPosition += VirtualMeter.CalculateRealPositionOfPoint(uPos1);
            }

            meanPosition /= placemarks.Count;

            // create value ditionary
             Dictionary<string, decimal> dict = new Dictionary<string, decimal>()
                                                {
                {"Total_Distance(m)",      totalDistance}
                //,{ "Mean_Northing (m)" ,    meanPosition.z }
                //,{ "Mean_Easting (m)" ,     meanPosition.x }
                //,{ "Mean_Altitude (m)" ,    meanPosition.y }
                                                };

            // create tool instance        
            return toolControllerComponent.CreateToolInstance("Line",
                "\nTotal_Distance (m): " + totalDistance.ToString("0.000"), 
                //"\n + Mean_Northing (m): " + meanPosition.z.ToString("0.000") +
                //"\n + Mean_Easting  (m): " + meanPosition.x.ToString("0.000") +
                //"\n + Mean_Altitude (m): " + meanPosition.y.ToString("0.000"),
                dict, placemarks);
        }
        return null;
    }

    public static void SaveToFile(string FilePath, List<GameObject> PlacemarkList)
    {
        // This will be the location of the Placemark.
        var point = new Point();
        point.Coordinate = new Vector(-13.163959, -72.545992);

        // This is the Element to save to the Kml file.
        var placemark = new Placemark();
        placemark.Geometry = point;
        placemark.Name = "Machu Picchu";

        // This allows us to save and Element easily.
        KmlFile kml = KmlFile.Create(placemark, false);
        using (var stream = System.IO.File.OpenWrite("my placemark.kml"))
        {
            kml.Save(stream);
        }
    }
}