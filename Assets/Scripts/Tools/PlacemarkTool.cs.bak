using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using System;
using UnityEngine.UI;
using System.Xml.Serialization;
using SharpKml;
using SharpKml.Base;
using SharpKml.Dom;
using SharpKml.Engine;

public class PlacemarkTool : Tool
{
    public override IEnumerator ToolCoroutine()
    {
        WaitForEndOfFrame wfeof = new WaitForEndOfFrame();
        ToolController.ToolIsCurrentlyRunning = true;
        ToolController.ToolControllerInterfaceIsCurrentlyRunning = false;

        toolControllerComponent.MeasurementControlUI.gameObject.SetActive(false);
        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS)
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.SetActive(false);

        // hold until trigger is released
        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS)
        {
            while (OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0.2f)
            {
                yield return wfeof;
            }
        }

        // temporary objects
        GameObject TempPlacemark, LastPlaceMark = null, TempPlacemarkInfo = null;
        List<GameObject> placemarks = new List<GameObject>();

        //Instantiate placemark
        TempPlacemark = Instantiate(toolControllerComponent.PlacemarkObject);
        TempPlacemark.transform.localScale *= toolControllerComponent.MarkerScale;
        TempPlacemark.name = "placemark";

        //boolean flags
        bool placemarkConfirmed = false;
        bool legalPlacemarkPlace = false;
        Vector3Decimal realPosition;

        //Handling Placemark
        RaycastHit hit;
        while (placemarkConfirmed == false)
        {
            //Trailing Waypoint
            if (Physics.Raycast(master.transform.position, directionMaster.transform.forward, out hit, 100000))
            {
                TempPlacemark.transform.position = hit.point + (toolControllerComponent.MarkerScale * 2) * Vector3.up;
                TempPlacemark.transform.eulerAngles = new Vector3(0f, directionMaster.transform.eulerAngles.y, directionMaster.transform.eulerAngles.z);
                legalPlacemarkPlace = true;

                //Showing info on toolInfo
                realPosition = VirtualMeter.CalculateGPSPosition(TempPlacemark.transform.position);

                toolControllerComponent.updateGUIMenus("Placemark",
                    "Lat(°): " + realPosition.z.ToString("0.0000000000000") +
                    "\nLon(°): " + realPosition.x.ToString("0.0000000000000") +
                    "\nAltitude (m): " + realPosition.y.ToString("0.000")
                );
            }
            else
            {
                //If not well placed then invalidate
                TempPlacemark.transform.position = master.transform.position + directionMaster.transform.forward * 100000;
                toolControllerComponent.updateGUIMenus("Placemark", "Lat(°): undefined \nLon(°): undefined \nAltitude (m): undefined");
                legalPlacemarkPlace = false;
            }

            if (
            (
            Input.GetMouseButton(0) ||
                (
                    (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS) &&
                    OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0.5f)
            )
            && legalPlacemarkPlace)
            {
                placemarkConfirmed = true;
                //ToolController.ToolIsCurrentlyRunning = false;

            }

            if (checkIfToolShouldQuit())
            {
                placemarkConfirmed = true;
                Destroy(TempPlacemark);
                ToolController.ToolIsCurrentlyRunning = false;
                yield break; // end coroutine early 
            }
            yield return wfeof;
        }

        placemarks.Add(TempPlacemark);
       
        //do calculations
        realPosition = VirtualMeter.CalculateGPSPosition(TempPlacemark.transform.position);

        // create value ditionary
        Dictionary<string, decimal> dict = new Dictionary<string, decimal>()
                                            {
            { "Lat(°)" ,    realPosition.z },
            { "Lon(°)" ,     realPosition.x },
            { "Altitude (m)" ,    realPosition.y }
                                            };

        // create tool instance
        toolControllerComponent.CreateToolInstance("Placemark",
            "Lat(°): " + realPosition.z.ToString("0.0000000000000") +
            "\nLon(°): " + realPosition.x.ToString("0.0000000000000") +
            "\nAltitude (m): " + realPosition.y.ToString("0.000"),
			Tool.toolType.PLACEMARK,
            dict, placemarks);

        //ToolController.ToolIsCurrentlyRunning = false;
        
    }

    public void startToolInterface()
    {


        toolControllerComponent.MeasurementControlUI.gameObject.transform.Find("UpperPanel").gameObject.transform.Find("Text").gameObject.GetComponent<Text>().text = "Placemark tool";


        toolControllerComponent.MeasurementControlUI.gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_placemark").gameObject.SetActive(true);
        toolControllerComponent.MeasurementControlUI.gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_line").gameObject.SetActive(false);
        toolControllerComponent.MeasurementControlUI.gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_polygon").gameObject.SetActive(false);
        toolControllerComponent.MeasurementControlUI.gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_ruler").gameObject.SetActive(false);

        toolControllerComponent.MeasurementControlUI.gameObject.transform.Find("Content").gameObject.transform.Find("StopTool").gameObject.GetComponent<Button>().onClick.AddListener(CancelButton);

        toolControllerComponent.MeasurementControlUI.SetActive(true);
        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS)
        {
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.transform.Find("UpperPanel").gameObject.transform.Find("Text").gameObject.GetComponent<Text>().text = "Placemark tool";
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.SetActive(true);

            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_placemark").gameObject.SetActive(true);
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_line").gameObject.SetActive(false);
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_polygon").gameObject.SetActive(false);
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.transform.Find("Content").gameObject.transform.Find("StartTool_ruler").gameObject.SetActive(false);

            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.transform.Find("Content").gameObject.transform.Find("StopTool").gameObject.GetComponent<Button>().onClick.AddListener(CancelButton);

            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").transform.localPosition = new Vector3(0.0f, -400.0f, 0.0f);

        }
        PauseAndGUIBehaviour.isToolMenu = false;
        ToolController.ToolControllerInterfaceIsCurrentlyRunning = true;

        //  StartCoroutine(this.OnUse());
    }

    public void CancelButton()
    {
        // toolControllerComponent.ToolMenuInstance.GetComponent<CanvasGroup>().alpha = 1;

        // StopGPSTracking(false);
        toolControllerComponent.MeasurementControlUI.SetActive(false);

        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS)
            {
            GameObject.Find("Canvas_Oculus").gameObject.transform.Find("MeasurementControlUI").gameObject.SetActive(false);
            }


        if (PauseAndGUIBehaviour.isPause)
                PauseAndGUIBehaviour.isPause = false;
            ToolController.ToolIsCurrentlyRunning = false;
        ToolController.ToolControllerInterfaceIsCurrentlyRunning = false;


        XmlSerializer xmls = new XmlSerializer(typeof(Kml));

        StringWriter sw = new StringWriter();
       // xmls.Serialize(sw, new Kml { Document ="a", Name="b" });

        var document = new Document { Name = "ExampleSeveralPoints.kml" };
        // this.credentials = new List<CredentialsSection> { credentialsSection, credentialsSection };

        string xml = sw.ToString();

        Debug.Log(xml);

    }



    public override GameObject LoadFromFile(string FilePath)
    {
        List<GameObject> placemarks = new List<GameObject>();

        if (File.Exists(FilePath))
        {
            String fileData = System.IO.File.ReadAllText(FilePath);
            String[] lines = fileData.Split("\n"[0]);
            GameObject TempPlacemark;

            foreach (String line in lines)
            {
                String[] data = line.Split(","[0]);
                if (data.Length == 3) // discard non-coordinate lines
                {
                    decimal x = decimal.Parse(data[0]);
                    decimal y = decimal.Parse(data[1]);
                    decimal z = decimal.Parse(data[2]);

                    TempPlacemark = Instantiate(toolControllerComponent.PlacemarkObject);
                    TempPlacemark.transform.localScale *= toolControllerComponent.MarkerScale;
                    TempPlacemark.name = "distance placemark";

                    TempPlacemark.transform.position = new Vector3((float)x, (float)y, (float)z); // this will need to account for offset
                    placemarks.Add(TempPlacemark);
                }
            }

            //do calculations
            Vector3Decimal realPosition = VirtualMeter.CalculateRealPositionOfPoint(placemarks[0].transform.position - 40 * Vector3.up);

            // create value ditionary
            Dictionary<string, decimal> dict = new Dictionary<string, decimal>()
                                                {
                { "Lat(°)" ,    realPosition.z },
                { "Lon(°)" ,     realPosition.x },
                { "Altitude(m)" ,    realPosition.y }
                                                };

            // create tool instance
            return toolControllerComponent.CreateToolInstance("Placemark",
                "Lat(°): " + realPosition.z.ToString("0.000") +
                "\nLon(°): " + realPosition.x.ToString("0.000") +
                "\nAltitude(m): " + realPosition.y.ToString("0.000"),
				Tool.toolType.PLACEMARK,
                dict, placemarks);
        }
        return null;
    }

    public static void SaveToFile(string FilePath, ToolInstance instance)
    {
        var kml = new SharpKml.Dom.Kml();
        kml.AddNamespacePrefix(KmlNamespaces.GX22Prefix, KmlNamespaces.GX22Namespace);

        // Create style 1
        var style = new Style();
        style.Id = "s_ylw-pushpin";
        style.Icon = new IconStyle();
        style.Icon.Hotspot = new Hotspot();
        style.Icon.Hotspot.X = 20.0;
        style.Icon.Hotspot.Y = 2.0;
        style.Icon.Hotspot.XUnits = Unit.Pixel;
        style.Icon.Hotspot.YUnits = Unit.Pixel;
        style.Icon.Icon = new IconStyle.IconLink(new Uri("http://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png"));
        style.Icon.Scale = 1.1;

        // Create style 2
        var style2 = new Style();
        style2.Id = "s_ylw-pushpin_hl";
        style2.Icon = new IconStyle();
        style2.Icon.Hotspot = new Hotspot();
        style2.Icon.Hotspot.X = 20.0;
        style2.Icon.Hotspot.Y = 2.0;
        style2.Icon.Hotspot.XUnits = Unit.Pixel;
        style2.Icon.Hotspot.YUnits = Unit.Pixel;
        style2.Icon.Icon = new IconStyle.IconLink(new Uri("http://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png"));
        style2.Icon.Scale = 1.3;

        //stylemap
        var pair1 = new Pair();
        pair1.State = StyleState.Normal;
        pair1.StyleUrl = new Uri("#s_ylw-pushpin", UriKind.Relative);

        var pair2 = new Pair();
        pair2.State = StyleState.Highlight;
        pair2.StyleUrl = new Uri("#s_ylw-pushpin_hl", UriKind.Relative);

        var stylemap = new StyleMapCollection();
        stylemap.Id = "m_ylw - pushpin";
        stylemap.Add(pair1);
        stylemap.Add(pair2);


        // This will be the location of the Placemark.
        Vector3Decimal realPosition = VirtualMeter.CalculateGPSPosition(instance.PlacemarkList[0].transform.position);       
        var point = new Point();
        point.Coordinate = new Vector((double)realPosition.x, (double)realPosition.z, (double)realPosition.y);


        // This is the Element to save to the Kml file.
        var placemark = new Placemark();
        placemark.Geometry = point;
        placemark.Name = instance.ToolTitle;
        placemark.StyleUrl = new Uri("#m_ylw-pushpin", UriKind.Relative);

        // create the document
        var document = new SharpKml.Dom.Document();
        document.Name = instance.ToolTitle;
        document.AddStyle(stylemap);
        document.AddStyle(style);
        document.AddStyle(style2);
        document.AddFeature(placemark);

        // set root 
        kml.Feature = document;

        // save to file
        KmlFile kmlf = KmlFile.Create(kml, false);
        using (var stream = System.IO.File.OpenWrite(FilePath + instance.ToolTitle + ".kml"))
        {
            kmlf.Save(stream);
        }
    }


}
