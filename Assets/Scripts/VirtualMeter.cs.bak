using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class VirtualMeter : MonoBehaviour
{
    public GameObject refTile = null;
    public static TileData td = null;

    // with the new .obj system the tiledata system seems unneeded
    // could we just manually set the offset and scaling factor once, in this script

    //positions then use CalculateRealPositionOfPoint() to get correct gps coordinates

    // real positions are then used for all calculations. 

    public static Vector3 terrainPosition = new Vector3(0.0f, 0.0f, 0.0f);
    public static decimal globalScaleFactor = 1.0m;
    public static decimal globalHeightScaleFactor = 1.0m;

    public static Vector3Decimal tileRealPosition = new Vector3Decimal(0.0m, 0.0m, 0.0m);

    public static GameObject WalkingMasterObject;
    public static GameObject FlyingMasterObject;
    public static GameObject DroneMasterObject;

    // Use this for initialization
    void Start()
    {
        // a messy solution, we need to unify how coordinates are calculated. 
        WalkingMasterObject = GameObject.Find("FPSController");
        FlyingMasterObject = GameObject.Find("TopCamera");
        DroneMasterObject = GameObject.Find("DroneModeCamera");

        if (refTile != null)
        {             
            td = refTile.GetComponent<TileData>();

            terrainPosition             = td.terrainPosition;
            globalScaleFactor           = td.globalScaleFactor;            
            globalHeightScaleFactor     = td.globalHeightScaleFactor;
            tileRealPosition            = td.tileRealPosition;
        }
    }

    public static float CalculateHeadingFromPositions(Vector3 Pos1, Vector3 Pos2)
    {
        Vector3 delta = Pos2 - Pos1;
        float heading = Vector3.SignedAngle(Vector3.forward, new Vector3(-delta.x, 0, -delta.z), Vector3.up);
        return (heading > 0) ? heading : (360 + heading);
    }

    public static float CalculateHeading(Vector3 DirectionVector)
    {
        float heading = Vector3.SignedAngle(Vector3.forward, -DirectionVector, Vector3.up);
        return (heading > 0) ? heading : (360 + heading);
    }

    public static float CalculateInclinationFromPositions(Vector3 Pos1, Vector3 Pos2)
    {
        Vector3 DirectionVector = Pos1 - Pos2;
        Vector3 FlattenedDirectionVector = Vector3.ProjectOnPlane(DirectionVector, Vector3.up).normalized;
        return Vector3.SignedAngle(DirectionVector, FlattenedDirectionVector, Vector3.Cross(DirectionVector, FlattenedDirectionVector));
    }

    public static float CalculateInclination(Vector3 DirectionVector)
    {        
        Vector3 FlattenedDirectionVector = Vector3.ProjectOnPlane(DirectionVector, Vector3.up).normalized;
        return Vector3.SignedAngle(DirectionVector, FlattenedDirectionVector, Vector3.Cross(DirectionVector, FlattenedDirectionVector));
    }

    public static Vector3Decimal CalculateRealPositionOfPoint(Vector3 point)
    {        
        Vector3Decimal temp;
        temp = (Vector3Decimal.Parse(point) - Vector3Decimal.Parse(terrainPosition));
        temp.x *= globalScaleFactor;
        temp.z *= globalScaleFactor;
        temp.y *= globalHeightScaleFactor;
        temp += tileRealPosition;        
        return temp;        
    }

    public static Vector3Decimal CalculateUnityPosition(Vector3 point)
    {
        return WalkingMasterObject.GetComponent<PositionController>().CalculateUnityPosition(point);
    }


    public static Vector3Decimal CalculateGPSPosition(Vector3 point)
    {
        return WalkingMasterObject.GetComponent<PositionController>().CalculateRealPosition(point);        
    }


    public static decimal CalculateRealDistance(Vector3 point1, Vector3 point2)
    {
        // calculate real positions
        Vector3Decimal Pos1 = VirtualMeter.CalculateRealPositionOfPoint(point1);
        Vector3Decimal Pos2 = VirtualMeter.CalculateRealPositionOfPoint(point2);

        return CalculateRealDistance(Pos1, Pos2);
    }

    public static decimal CalculateRealDistance(Vector3Decimal point1, Vector3Decimal point2)
    {     
        // pythagoras 
        decimal a = point1.x - point2.x;
        decimal b = point1.y - point2.y;
        decimal c = point1.z - point2.z;
        
        return (decimal)System.Math.Sqrt((double)(a * a + b * b + c * c)); // lose precision :/ 
    }

    public static decimal CalculateVerticalRealDistance2D(Vector3 point1, Vector3 point2)
    {
        // calculate real positions
        Vector3Decimal Pos1 = VirtualMeter.CalculateRealPositionOfPoint(point1);
        Vector3Decimal Pos2 = VirtualMeter.CalculateRealPositionOfPoint(point2);

        return CalculateVerticalRealDistance2D(Pos1, Pos2);
    }
    public static decimal CalculateRealDistance2D(Vector3 point1, Vector3 point2)
    {
        // calculate real positions
        Vector3Decimal Pos1 = VirtualMeter.CalculateRealPositionOfPoint(point1);
        Vector3Decimal Pos2 = VirtualMeter.CalculateRealPositionOfPoint(point2);

        return CalculateRealDistance2D(Pos1, Pos2);
    }
    public static decimal CalculateRealDistance2D(Vector3Decimal point1, Vector3Decimal point2)
    {
        // pythagoras 
        decimal a = point1.x - point2.x;
        decimal b = point1.z - point2.z;


      //  return (decimal)(Mathf.Max((float)point1.x, (float)point2.x) - Mathf.Min((float)point1.x, (float)point2.x)); 
        // lose precision :/ 
                                                                                                                    
         return (decimal)System.Math.Sqrt((double)(a * a + b * b)); // lose precision :/ 
    }

    public static decimal CalculateVerticalRealDistance2D(Vector3Decimal point1, Vector3Decimal point2)
    {



        return (decimal)(Mathf.Max((float)point1.y, (float)point2.y) - Mathf.Min((float)point1.y, (float)point2.y)); // lose precision :/ 
    }

    public static decimal CalculateGroundDistance(Vector3 start, Vector3 end, LineRenderer lr = null)
    {
        float distance = 0;
        float linearDistance = Vector3.Distance(start, end);
        float linearStep = 0.01f;
        Vector3 p1 = start;
        Vector3 p2 = start;
        Vector3 step;
        RaycastHit hit;
        int j = 0;
        if (lr != null)
        {
            lr.positionCount = ((int)(linearDistance / linearStep)) + 2;
            //lr.SetPosition(j++, p1);
        }

        // offset y positions
        float y1 = start.y + 1000;
        float y2 = end.y + 1000;

        start.y = Mathf.Max(y1, y2);
        end.y = Mathf.Max(y1, y2);


        //calculate ray vector
        Vector3 FlattenedVector = Vector3.ProjectOnPlane((end - start), Vector3.up).normalized;
        Vector3 RightVector = Quaternion.Euler(0, -90, 0) * FlattenedVector; // 
        Vector3 RayVector = Vector3.Cross((end - start).normalized, RightVector); 

        //Begin process
        //if (start.y > end.y)
           // end.y = start.y;
        //else
            //start.y = end.y;

         for (float i = 0f; i <= linearDistance; i += linearStep)
         {
            // step along line between points
            step = Vector3.Lerp(start, end, i / linearDistance);            

            // cast ray down from point
            if (Physics.Raycast(step, RayVector, out hit, 3000))
            {
                p1 = p2;
                p2 = hit.point;
            }
            // cast ray up from point
            else if (Physics.Raycast(step, -RayVector, out hit, 3000))
            {
                p1 = p2;
                p2 = hit.point;
            }
            //if no points found
            else
            {
                print("error at step " + j);
                Vector3 pastp1 = p1;
                p1 = p2;
                p2 = p2 + Vector3.Normalize(p2 - pastp1) * linearStep;
            }
            
            // add to distance
            distance += (float)VirtualMeter.CalculateRealDistance(p1, p2);

            //if a line renderer exists
            if (lr != null)
            {
                // add a position to it
                lr.SetPosition(j, p2);
                j++;
            }
         }

        // set any final positions to the correct position
        while (lr != null && j < lr.positionCount)
        {
            lr.SetPosition(j, p2);
            j++;
        }
        


        //End process
        decimal decimalDistance = (decimal)distance;
        return decimalDistance;
    }
    
}
    /*
    IEnumerator WaypointCoroutine()
    {

        print("yes");

        WaitForEndOfFrame wfeof = new WaitForEndOfFrame();

        // hold until trigger is released
        // this avoids instant placement 
        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS)
        {
            while (OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0.2f)
            {
                yield return wfeof;
            }
        }

        toolInfo.GetComponentInChildren<Text>(true).text = "Placemark";
        toolInfo.SetActive(true);

        if (oculusToolInfo)
        {
            oculusToolInfo.GetComponentInChildren<Text>(true).text = "Placemark";
            oculusToolInfo.SetActive(true);
        }

        //Instantiate Waypoint
        camera = GetComponentInChildren<Camera>();
        TempPlacemark = Instantiate(Placemark);
        TempPlacemark.transform.localScale *= LocalMarkerScale;
        TempPlacemark.name = "placemark";
        bool waypointConfirmed = false, legalWaypointPlace = false;

        GameObject master, directionMaster;
        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS)
        {
            master = OculusTouchRight;
            directionMaster = OculusTouchRight;
        }
        else
        {
            master = gameObject;
            directionMaster = camera.gameObject;
        }

        //Handling Waypoint        
        RaycastHit hit;
        Vector3Decimal realPosition = new Vector3Decimal(0.0m, 0.0m, 0.0m);
        while (waypointConfirmed == false)
        {
            //Trailing Waypoint
            if (Physics.Raycast(master.transform.position, directionMaster.transform.forward, out hit, 100000))
            {
                TempPlacemark.transform.position = hit.point + (LocalMarkerScale * 2) * Vector3.up; // this solves a problem that shouldn't exist, scaling needs to be sorted 
                TempPlacemark.transform.eulerAngles = new Vector3(
                        0f,
                        directionMaster.transform.eulerAngles.y,
                        directionMaster.transform.eulerAngles.z
                        );
                legalWaypointPlace = true;
                //Showing info on toolInfo
                realPosition = GetComponent<PositionController>().CalculateRealPositionOfPoint(TempPlacemark.transform.position);
                toolInfo.GetComponentsInChildren<Text>()[1].text =
                                "Northing (m): " + realPosition.z.ToString("0.000") +
                                "\nEasting (m): " + realPosition.x.ToString("0.000") +
                                "\nAltitude (m): " + realPosition.y.ToString("0.000");

                if (oculusToolInfo)
                {
                    oculusToolInfo.GetComponentsInChildren<Text>()[1].text =
                                "Northing (m): " + realPosition.z.ToString("0.000") +
                                "\nEasting (m): " + realPosition.x.ToString("0.000") +
                                "\nAltitude (m): " + realPosition.y.ToString("0.000");
                }
            }
            else
            {
                //If not well placed invalidate
                TempPlacemark.transform.position = master.transform.position + directionMaster.transform.forward * 100000;
                legalWaypointPlace = false;
                toolInfo.GetComponentsInChildren<Text>()[1].text =
                                "Northing (m): undefined" +
                                "\nEasting (m): undefined" +
                                "\nAltitude (m): undefined";
                if (oculusToolInfo)
                {
                    oculusToolInfo.GetComponentsInChildren<Text>()[1].text =
                                "Northing (m): undefined" +
                                "\nEasting (m): undefined" +
                                "\nAltitude (m): undefined";
                }
            }

            //Let confirm waypoint
            if (
                (
                Input.GetMouseButton(0) ||
                    (
                        (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS) &&
                        OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0.8f
                    )
                )
                && legalWaypointPlace)
            {               
                waypointConfirmed = true;
            }
            yield return wfeof;
        }

        //Adding legal Waypoint and Add info
        int i = 0;
        foreach (Transform child in PlacemarkScrollView.GetComponentsInChildren<Transform>(true))
        {
            if (child.gameObject != PlacemarkScrollView && child.parent.gameObject == PlacemarkScrollView)
                i++;
        }

        // we should relook at this method after santorini  
        /*
        TempPlacemarkInfo = Instantiate(PlacemarkInfo, PlacemarkScrollView.transform);
        TempPlacemarkInfo.transform.localPosition = new Vector3(91.5f, -50 * i - 30, 0);

        TempPlacemarkInfo.GetComponent<PlacemarkData>().position = TempPlacemark.transform.position - 40 * Vector3.up;
        TempPlacemarkInfo.GetComponent<PlacemarkData>().realPosition = GetComponent<PositionController>().CalculateRealPositionOfPoint(TempPlacemark.transform.position - 40 * Vector3.up);
        TempPlacemarkInfo.GetComponentInChildren<Text>().text =
                        "Northing (m): " + TempPlacemarkInfo.GetComponent<PlacemarkData>().realPosition.z.ToString("0.000") +
                        "\nEasting (m): " + TempPlacemarkInfo.GetComponent<PlacemarkData>().realPosition.x.ToString("0.000") +
                        "\nAltitude (m): " + TempPlacemarkInfo.GetComponent<PlacemarkData>().realPosition.y.ToString("0.000");
       

        print("Placemark Placed");

        isWCrunning = false;
        isActiveWaypoint = false;

        //toolInfo.GetComponentInChildren<Text>().text = "";
        toolInfo.GetComponentsInChildren<Text>()[1].text =
                        "Northing (m): " + realPosition.z.ToString("0.000") +
                        "\nEasting (m): " + realPosition.x.ToString("0.000") +
                        "\nAltitude (m): " + realPosition.y.ToString("0.000");

        if (oculusToolInfo)
        {
            oculusToolInfo.GetComponentsInChildren<Text>()[1].text =
                        "Northing (m): " + realPosition.z.ToString("0.000") +
                        "\nEasting (m): " + realPosition.x.ToString("0.000") +
                        "\nAltitude (m): " + realPosition.y.ToString("0.000");
        }

        //toolInfo.SetActive(false);
    }

    IEnumerator TopographicProfileCoroutine()
    {
        WaitForEndOfFrame wfeof = new WaitForEndOfFrame();
        // hold until trigger is released
        // this avoids instant placement 
        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS)
        {
            while (OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0.2f)
            {
                yield return wfeof;
            }
        }


        toolInfo.GetComponentInChildren<Text>(true).text = "Topographic Profile";
        toolInfo.SetActive(true);

        if (oculusToolInfo)
        {
            oculusToolInfo.GetComponentInChildren<Text>(true).text = "Topographic Profile";
            oculusToolInfo.SetActive(true);
        }

        camera = GetComponentInChildren<Camera>();
        List<Vector3> placemarks = new List<Vector3>();

        GameObject master, directionMaster;
        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS)
        {
            master = OculusTouchRight;
            directionMaster = OculusTouchRight;
        }
        else
        {
            master = gameObject;
            directionMaster = camera.gameObject;
        }

        //Do twice
        for (int times = 0; times < 2; times++)
        {
            //Instantiate placemark
            TempPlacemark = Instantiate(Placemark);
            TempPlacemark.transform.localScale *= LocalMarkerScale;
            TempPlacemark.name = "topographic placemark";
            bool placemarkConfirmed = false, legalPlacemarkPlace = false;
            bool wasHolding = true;

            //Handling Placemark
            RaycastHit hit;
            Vector3Decimal realPosition;
            while (placemarkConfirmed == false)
            {
                if (StateSingleton.stateView != StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView != StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS)
                {
                    if (wasHolding == true && OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) < 0.2f)
                        wasHolding = false;
                }

                //Trailing Waypoint
                if (Physics.Raycast(master.transform.position, directionMaster.transform.forward, out hit, 100000))
                {
                    TempPlacemark.transform.position = hit.point + (LocalMarkerScale * 2) * Vector3.up;
                    TempPlacemark.transform.eulerAngles = new Vector3(
                            0f,
                            directionMaster.transform.eulerAngles.y,
                            directionMaster.transform.eulerAngles.z
                            );
                    legalPlacemarkPlace = true;

                    //Showing info on toolInfo
                    realPosition = GetComponent<PositionController>().CalculateRealPositionOfPoint(TempPlacemark.transform.position - 40 * Vector3.up);
                    toolInfo.GetComponentsInChildren<Text>()[1].text =
                                    ((times == 0) ? "First " : "Second ") + "Placemark" +
                                    "\nNorthing (m): " + realPosition.z.ToString("0.000") +
                                    "\nEasting (m): " + realPosition.x.ToString("0.000") +
                                    "\nAltitude (m): " + realPosition.y.ToString("0.000");

                    if (oculusToolInfo)
                    {
                        oculusToolInfo.GetComponentsInChildren<Text>()[1].text =
                                    ((times == 0) ? "First " : "Second ") + "Placemark" +
                                    "\nNorthing (m): " + realPosition.z.ToString("0.000") +
                                    "\nEasting (m): " + realPosition.x.ToString("0.000") +
                                    "\nAltitude (m): " + realPosition.y.ToString("0.000");
                    }
                }
                else
                {
                    //If not well placed then invalidate
                    TempPlacemark.transform.position = master.transform.position + directionMaster.transform.forward * 100000;
                    legalPlacemarkPlace = false;

                    //Showing on toolinfo
                    toolInfo.GetComponentsInChildren<Text>()[1].text =
                                    ((times == 0) ? "First " : "Second ") + "Placemark" +
                                    "\nNorthing (m): undefined" +
                                    "\nEasting (m): undefined" +
                                    "\nAltitude (m): undefined";
                    if (oculusToolInfo)
                    {
                        oculusToolInfo.GetComponentsInChildren<Text>()[1].text =
                                    ((times == 0) ? "First " : "Second ") + "Placemark" +
                                    "\nNorthing (m): undefined" +
                                    "\nEasting (m): undefined" +
                                    "\nAltitude (m): undefined";
                    }
                }

                //Let confirm waypoint
                if (
                (
                Input.GetMouseButton(0) ||
                    (
                        (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS) &&
                        OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0.5f && wasHolding == false
                    )
                )
                && legalPlacemarkPlace)
                {

                    //Menu di conferma//


                    placemarkConfirmed = true;
                    placemarks.Add(TempPlacemark.transform.position - (LocalMarkerScale * 2) * Vector3.up);
                }
                yield return wfeof;
            }
            while (Input.GetMouseButton(0))
                yield return wfeof;
        }
        LineRenderer lr = TempPlacemark.AddComponent<LineRenderer>() as LineRenderer;
        lr.startWidth = lr.endWidth = (float)(LocalMarkerScale * 0.5f);
        lr.material = lineTopographicMaterial;

        decimal distance = Vector3Decimal.Distance(
            GetComponent<PositionController>().CalculateRealPositionOfPoint(placemarks[0]),
            GetComponent<PositionController>().CalculateRealPositionOfPoint(placemarks[1])
            );

        //Showing on toolinfo
        toolInfo.GetComponentsInChildren<Text>()[1].text = "Calculating profile\nPlease wait...";
        if (oculusToolInfo)
        {
            oculusToolInfo.GetComponentsInChildren<Text>()[1].text = "Calculating profile\nPlease wait...";
        }
        yield return wfeof;


        decimal globalScaleFactor = 1.0m;
        if (GetComponent<PositionController>().td)
        {
            globalScaleFactor = GetComponent<PositionController>().td.globalScaleFactor;
        }

        decimal profileDistance = CalculateGroundDistance(
            placemarks[0],
            placemarks[1],
            lr,
            globalScaleFactor
            );

        print("Topographic Profile Placed");

        //Showing on toolinfo
        toolInfo.GetComponentsInChildren<Text>()[1].text =
            "Minimum Distance (m): " + distance.ToString("0.000") +
            "\nTopographic Profile Distance (m): " + profileDistance.ToString("0.000");

        if (oculusToolInfo)
        {
            oculusToolInfo.GetComponentsInChildren<Text>()[1].text =
            "Minimum Distance (m): " + distance.ToString("0.000") +
            "\nTopographic Profile Distance (m): " + profileDistance.ToString("0.000");
        }

        isTPCrunning = false;
        isActiveTopographicProfile = false;

        //toolInfo.GetComponentInChildren<Text>().text = "";
        //toolInfo.GetComponentsInChildren<Text>()[1].text = "";
        //toolInfo.SetActive(false);


        //Plotting graph
        StartCoroutine(PlotGraphCoroutine(lr));
    }

    IEnumerator PlotGraphCoroutine(LineRenderer lr)
    {
        //DD_DataDiagram dataDiagram = TopographicGraph.GetComponentInChildren<DD_DataDiagram>(true);

        //Color color = Color.HSVToRGB((h += 0.1f) > 1 ? (h - 1) : h, 0.8f, 0.8f);
        //GameObject line = dataDiagram.AddLine("Heights");

        UIGraphRenderer graph = TopographicGraph.GetComponentInChildren<UIGraphRenderer>(true);
        graph.ClearPoints();

        for (int i = 0; i < lr.positionCount; i++)
        {
            graph.AddPoint(new Vector2(i, lr.GetPosition(i).y) );            
        }

        TopographicGraph.SetActive(true);        

        print("End coroutine" + this.name);
        yield return new WaitForEndOfFrame();
    }

    IEnumerator DistanceCoroutine()
    {
        WaitForEndOfFrame wfeof = new WaitForEndOfFrame();
        // hold until trigger is released
        // this avoids instant placement 
        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS)
        {
            while (OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0.2f)
            {
                yield return wfeof;
            }
        }

        toolInfo.GetComponentInChildren<Text>(true).text = "Distance";
        toolInfo.SetActive(true);

        if (oculusToolInfo)
        {
            oculusToolInfo.GetComponentInChildren<Text>(true).text = "Distance";
            oculusToolInfo.SetActive(true);
        }

        camera = GetComponentInChildren<Camera>();
        List<Vector3> placemarks = new List<Vector3>();
        
        GameObject master, directionMaster;
        if (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS)
        {
            master = OculusTouchRight;
            directionMaster = OculusTouchRight;
        }
        else
        {
            master = gameObject;
            directionMaster = camera.gameObject;
        }

        //Do twice
        for (int times = 0; times < 2; times++)
        {
            //Instantiate placemark
            TempPlacemark = Instantiate(Placemark);
            TempPlacemark.transform.localScale *= LocalMarkerScale;
            TempPlacemark.name = "distance placemark";
            bool placemarkConfirmed = false, legalPlacemarkPlace = false;
            bool wasHolding = true;

            //Handling Placemark
            RaycastHit hit;
            Vector3Decimal realPosition;
            while (placemarkConfirmed == false)
            {
                if (StateSingleton.stateView != StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView != StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS)
                {
                    if (wasHolding == true && OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) < 0.2f)
                        wasHolding = false;
                }
                //Trailing Waypoint
                if (Physics.Raycast(master.transform.position, directionMaster.transform.forward, out hit, 100000))
                {
                    TempPlacemark.transform.position = hit.point + (LocalMarkerScale * 2) * Vector3.up;
                    TempPlacemark.transform.eulerAngles = new Vector3(
                            0f,
                            directionMaster.transform.eulerAngles.y,
                            directionMaster.transform.eulerAngles.z
                            );
                    legalPlacemarkPlace = true;

                    //Showing info on toolInfo
                    realPosition = GetComponent<PositionController>().CalculateRealPositionOfPoint(TempPlacemark.transform.position - 40 * Vector3.up);
                    toolInfo.GetComponentsInChildren<Text>()[1].text =
                                    ((times == 0) ? "First " : "Second ") + "Placemark" +
                                    "\nNorthing (m): " + realPosition.z.ToString("0.000") +
                                    "\nEasting (m): " + realPosition.x.ToString("0.000") +
                                    "\nAltitude (m): " + realPosition.y.ToString("0.000");
                    if (oculusToolInfo)
                    {
                        oculusToolInfo.GetComponentsInChildren<Text>()[1].text =
                                    ((times == 0) ? "First " : "Second ") + "Placemark" +
                                    "\nNorthing (m): " + realPosition.z.ToString("0.000") +
                                    "\nEasting (m): " + realPosition.x.ToString("0.000") +
                                    "\nAltitude (m): " + realPosition.y.ToString("0.000");
                    }
                }
                else
                {
                    //If not well placed then invalidate
                    TempPlacemark.transform.position = master.transform.position + directionMaster.transform.forward * 100000;
                    legalPlacemarkPlace = false;

                    //Showing on toolinfo
                    toolInfo.GetComponentsInChildren<Text>()[1].text =
                                    ((times == 0) ? "First " : "Second ") + "Placemark" +
                                    "\nNorthing (m): undefined" +
                                    "\nEasting (m): undefined" +
                                    "\nAltitude (m): undefined";

                    if (oculusToolInfo)
                    {
                        oculusToolInfo.GetComponentsInChildren<Text>()[1].text =
                                    ((times == 0) ? "First " : "Second ") + "Placemark" +
                                    "\nNorthing (m): undefined" +
                                    "\nEasting (m): undefined" +
                                    "\nAltitude (m): undefined";
                    }
                }

                //Let confirm waypoint
                if (
                (
                Input.GetMouseButton(0) ||
                    (
                        (StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_OCULUS || StateSingleton.stateView == StateSingleton.StateView.MODE2D_PLUS_3DVP_PLUS_OCULUS) &&
                        OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger) > 0.5f && wasHolding == false
                    )
                )
                && legalPlacemarkPlace)
                {

                    //Menu di conferma//


                    placemarkConfirmed = true;
                    placemarks.Add(TempPlacemark.transform.position - (LocalMarkerScale * 2) * Vector3.up);
                }
                yield return wfeof;
            }
            while (Input.GetMouseButton(0))
                yield return wfeof;
        }
        LineRenderer lr = TempPlacemark.AddComponent<LineRenderer>() as LineRenderer;
        lr.startWidth = lr.endWidth = (float)(LocalMarkerScale * 0.5f);
        lr.material = lineDistanceMaterial;

        lr.SetPosition(0, placemarks[0] + Vector3.up * (float)(LocalMarkerScale * 0.5f));
        lr.SetPosition(1, placemarks[1] + Vector3.up * (float)(LocalMarkerScale * 0.5f));

        Vector3Decimal delta =
            GetComponent<PositionController>().CalculateRealPositionOfPoint(placemarks[1]) -
            GetComponent<PositionController>().CalculateRealPositionOfPoint(placemarks[0]);

        decimal globalScaleFactor = 1.0m;
        if (GetComponent<PositionController>().td)
        {
            globalScaleFactor = GetComponent<PositionController>().td.globalScaleFactor;
        }

        
        decimal profileDistance = CalculateSuperficialDistance(
            placemarks[0],
            placemarks[1],
            null,
            globalScaleFactor
            );
            

        float linearDistance = Vector3.Distance(placemarks[0], placemarks[1]);
        decimal profileDistance = (decimal)linearDistance * globalScaleFactor;

        print("Distance Placed");
        float heading = Vector3.SignedAngle(Vector3.forward, new Vector3((float)delta.x, 0, (float)delta.z), Vector3.up);

        Vector3 DirectionVector = placemarks[1] - placemarks[0];
        Vector3 FlattenedDirectionVector = Vector3.ProjectOnPlane(DirectionVector, Vector3.up).normalized;
        float inclination = Vector3.SignedAngle(DirectionVector, FlattenedDirectionVector, Vector3.Cross(DirectionVector, FlattenedDirectionVector));

        decimal GroundDistance = CalculateGroundDistance(placemarks[0], placemarks[1], null, globalScaleFactor);

        //Showing on toolinfo
        toolInfo.GetComponentsInChildren<Text>()[1].text =
            "Map Length (m): " + Vector3Decimal.Magnitude(delta).ToString("0.000") +
            "\nLine Length (m): " + profileDistance.ToString("0.000") +
            "\nGround Distance (m): " + GroundDistance.ToString("0.000") +
            //"\nNorthing Distance: " + ((delta.z>0) ? delta.z : -delta.z).ToString("0.000") +
            //"\nEasting Distance: " + ((delta.x > 0) ? delta.x : -delta.x).ToString("0.000") +
            //"\nAltitude Distance: " + ((delta.y > 0) ? delta.y : -delta.y).ToString("0.000");
            "\nHeading (°): " + ((heading > 0) ? heading : (360 + heading)).ToString("0.0")+
            "\nInclination (°): " + (inclination).ToString("0.0");

        if (oculusToolInfo)
        {
            oculusToolInfo.GetComponentsInChildren<Text>()[1].text =
            "Map Length (m): " + Vector3Decimal.Magnitude(delta).ToString("0.000") +
            "\nLine Length (m): " + profileDistance.ToString("0.000") +
            "\nGround Distance (m): " + GroundDistance.ToString("0.000") +
            //"\nNorthing Distance: " + ((delta.z>0) ? delta.z : -delta.z).ToString("0.000") +
            //"\nEasting Distance: " + ((delta.x > 0) ? delta.x : -delta.x).ToString("0.000") +
            //"\nAltitude Distance: " + ((delta.y > 0) ? delta.y : -delta.y).ToString("0.000");
            "\nHeading (°): " + ((heading > 0) ? heading : (360 + heading)).ToString("0.0") +
            "\nInclination (°): " + (inclination).ToString("0.0");
        }


        isDCrunning = false;
        isActiveDistance = false;        
    }    
}
*/