using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

// based on
// https://forum.unity.com/threads/new-ui-and-line-drawing.253772/

public class UIGraphRenderer : Graphic {
    private List<Vector2> Points = new List<Vector2>();
    
    private bool BoundsSet = false;
    private float MinX, MaxX, MinY, MaxY;
    
    public Text xAxisMax;
    public Text yAxisMax;
    public Text xAxisMin;
    public Text yAxisMin;

    public float LineWidth = 3.0f;
    public float backgroundLineWorldHeight = 10.0f;    
    public  Color axesColour = Color.black;
    
    protected override void OnPopulateMesh(VertexHelper vh)
    {
        vh.Clear();
        
        // set default bounds
        if (!BoundsSet)
        {
            MinX = 0.0f;
            MaxX = 1.0f;
            MinY = 0.0f;
            MaxY = 1.0f;            
        }

        Vector2 origin = GetRelativePosition(new Vector2(0.0f, 0.0f));
        // draw background lines
        
        float d = MinY;
        while (backgroundLineWorldHeight != 0.0f && d < MaxY)
        {
            d += backgroundLineWorldHeight;
            Vector2 linePosition = GetRelativePosition(new Vector2(0.0f, d));

            DrawLine(vh,
                GetPointInRectangleSpace(new Vector2(0.0f, linePosition.y)),
                GetPointInRectangleSpace(new Vector2(1.0f, linePosition.y)),
                new Vector2(0.0f, LineWidth * 0.5f),
                Color.grey
                );
        }

        // draw axes
        DrawLine(vh,
            GetPointInRectangleSpace(new Vector2(origin.x, 0.0f)),
            GetPointInRectangleSpace(new Vector2(origin.x, 1.0f)),
            new Vector2(-LineWidth, 0.0f),
            axesColour
            );

        DrawLine(vh,
            GetPointInRectangleSpace(new Vector2(0.0f, origin.y)) - new Vector2(LineWidth, 0.0f),
            GetPointInRectangleSpace(new Vector2(1.0f, origin.y)) + new Vector2(LineWidth, 0.0f),
            new Vector2(0.0f, -LineWidth),
            axesColour
            );


        // draw chart
        if (Points == null || Points.Count < 2)
        {
            Vector2 corner1 = GetPointInRectangleSpace(new Vector2(0.0f, 0.0f));
            Vector2 corner2 = GetPointInRectangleSpace(new Vector2(1.0f, 1.0f));
            DrawLine(vh, corner1, corner2, new Vector2(0.0f, LineWidth), color);
        }
        else
        {                  
            for (int i = 0; i < Points.Count - 1; i++)
            {
                DrawLine(vh, i, i + 1, new Vector2(0.0f, LineWidth));
            }
        }        
    }

    protected void DrawLine(VertexHelper vh, int p1, int p2, Vector2 LineOffset)
    {
        Vector2 point1 = GetPointInRectangleSpace(GetRelativePosition(Points[p1]));
        Vector2 point2 = GetPointInRectangleSpace(GetRelativePosition(Points[p2]));

        DrawLine(vh, point1, point2, LineOffset, color);
    }

    protected void DrawLine(VertexHelper vh, Vector2 point1, Vector2 point2, Vector2 LineOffset, Color _colour)
    {
        int cvc = vh.currentVertCount;
        UIVertex vert = UIVertex.simpleVert;

        vert.position = new Vector2(point1.x, point1.y);
        vert.color = _colour;
        vh.AddVert(vert);

        vert.position = new Vector2(point1.x, point1.y) + LineOffset;
        vert.color = _colour;
        vh.AddVert(vert);

        vert.position = new Vector2(point2.x, point2.y);
        vert.color = _colour;
        vh.AddVert(vert);

        vert.position = new Vector2(point2.x, point2.y) + LineOffset;
        vert.color = _colour;
        vh.AddVert(vert);
                
        vh.AddTriangle(0 + cvc, 1 + cvc, 2 + cvc);
        vh.AddTriangle(1 + cvc, 2 + cvc, 3 + cvc);
    }

    protected Vector2 GetRelativePosition(Vector2 Pos)
    {        
        float x = (Pos.x - MinX) / (MaxX - MinX);
        float y = (Pos.y - MinY) / (MaxY - MinY);

        x = Mathf.Clamp(x, 0.0f, 1.0f);
        y = Mathf.Clamp(y, 0.0f, 1.0f);
        return new Vector2(x, y);
    }

    protected Vector2 GetPointInRectangleSpace(Vector2 Pos)
    {
        Vector2 newPoint = Pos;

        newPoint.x -= rectTransform.pivot.x;
        newPoint.y -= rectTransform.pivot.y;

        newPoint.x *= rectTransform.rect.width;
        newPoint.y *= rectTransform.rect.height;

        return newPoint;
    }

    public void AddPoint(Vector2 Point)
    {
        Points.Add(Point);

        if (!BoundsSet) // set bounds
        {
            MaxX = Point.x;
            MinX = Point.x;
            MaxY = Point.y;
            MinY = Point.y; 
            BoundsSet = true;
        }
        else
        {
            if (Point.x > MaxX) { MaxX = Point.x; }
            else if (Point.x < MinX) { MinX = Point.x; }

            if (Point.y > MaxY) { MaxY = Point.y; }
            else if (Point.y < MinY) { MinY = Point.y; }
        }
        if (xAxisMax) { xAxisMax.text = Points[Points.Count - 1].x.ToString("0.000"); }
        if (yAxisMax) { yAxisMax.text = MaxY.ToString("0.000"); }
        if (xAxisMin) { xAxisMin.text = Points[0].x.ToString("0.000"); }
        if (yAxisMin) { yAxisMin.text = MinY.ToString("0.000"); }
        SetAllDirty();
    }

    public void ClearPoints()
    {
        Points.Clear();
        SetAllDirty();
    }


}
